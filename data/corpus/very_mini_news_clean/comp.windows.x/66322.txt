path from ware peter ware newsgroups subject frequently asked questions faq date apr organization the ohio state university dept of computer and info science lines approved expires may gmt ware summary answers about the window system widgets and xt library version id v ware exp the x toolkit a monthly posting this article contains the answers to some frequently asked questions faq from about the x toolkit to submit questions preferably with an answer send email to ware many faqs including this one are available on the archive site in the directory the name under which a faq is archived appears in the line at the top of the article this faq is archived as all code fragments are public domain contents xt glossary software versions related why does my application core dump when i use how do i use a different visual than the default which visual should an application use why do only shell widgets have a visual which visual depth and do shells i done all the above and i still get a error why why does my widget get destroyed when i call how do i exit but still execute the how do i resize a shell widget why ca handle files what good books and magazines are there on xt what widgets are available what alternatives to the are there how do i pass a float value to how do i write a resource converter how do i open multiple displays what changed from to to where are the resources loaded from what order are executed in how do i know if a widget is visible how do i a widget in xt why use etc how to debug an xt application why do and work what is and how can i implement drag and drop xt glossary o the xt implement an object oriented interface to c code to allow useful graphical components to be created included with this are classes that provide the base functionality object core composite constraint shell etc the terms xt and are used however they are used very precisely to mean a specific library of the x window system in particular it does not include the athena motif or any other widget set without further widgets the are not especially useful o a widget refers to a user interface abstraction created via xt the precise use is any object that is a subclass of the core class it is used loosely to refer to anything that is a subclass of the object class although these are more accurately called widgets or gadgets o is the c interface to the protocol it is one layer below the xt typically a widget uses relatively few functions because xt provides most such services although an understanding of helps with problems software versions the following are the latest versions of xt based software software version released next expected patch none patch athena widgets see motif none none related david lewis craft faq maintains the faq on it is posted monthly on and located on export in liam lee posts an faq list on open look to jan jan posts an faq list on motif to peter ware ware posts an faq list for it is on export in why does my application core dump when i use in brief xt and most widget sets have no mutual exclusion for critical sections any interrupt handler is likely to leave one of the above libraries in an inconsistent state such as all the appropriate flags not yet set pointers in the middle of a list etc note that the ansi c standard points out that behavior of a signal handler is undefined if the signal handler calls any function other than signal itself so this is not a problem specific to and xt the posix specification mentions other functions which may be called safely but it may not be assumed that these functions are called by or xt functions the only safe way to deal with signals is to set a flag in the interrupt handler this flag later needs to be checked either by a work procedure or a timeout callback it is incorrect to add either of these in the interrupt handler as another note it is dangerous to add a work procedure that never finishes this effectively any work procedures previously added and so they will never be called another option is to open a pipe tell the event loop about the read end using and then the signal handler can write a byte to the write end of the pipe for each signal however this could your process if the pipe fills up why do the deal with this problem primarily because it is supposed to be a portable layer to any hardware and operating system is that a good enough reason i do think so note the article in the x journal and the example in volume are in error how do i use a different visual than the default this requires a more complicated answer than it should a window has three things that are visual specific the visual and border all widgets have their own and resource only shell widgets have visual resources another questions deals with why shells have a visual the default value of these resources is which does exactly what it says in the shell widget gets as and when any one of the three resources is not properly set a error occurs when the window is created they are not properly set because each of the values depends on the visual being used how to get this to work there are two parts to the answer the first is if you want an application to start with a particular visual and the second is if you want a particular shell within an application to start with a different visual the second is actually easier because the basic information you need is available the first is a little harder because you need to initialize much of the toolkit yourself in order to determine the needed information some sample code to start up an application using something other than the default visual to compile cc visual to run blue yellow you need to move the mouse to get the particular to install include include include typedef struct visual int depth options resources visual visual sizeof visual visual null depth depth sizeof int depth null desc null null int main argv int char app the application context widget top widget display display char saved argument vector int saved argument count created template for find visual returned list of int count number of only arg args cardinal char test char test save the command line arguments char sizeof char char argv char sizeof char the following creates a widget so we can retrieve the appropriate visual resource top app class desc desc argv string null args top top options resources resources args if top args now we create an appropriate we could use a default based on the class of the visual we could examine some property on the to find the right we could do all sorts of things top args now find some information about the visual count if count args top now create the real widget args args top char null class args display the application and loop handling all events top app return which visual should an application use this is a point that can be argued about but one opinion is there is no way for an application to know the appropriate visual it has to be specified by the user if you disagree with this then your application probably falls into the category of always using the default visual or it is hardware specific and expects some particular visual such as with an extension or some such why no application runs in isolation depending on the way a server resources i may not always want your application to run in mode if it is going to mess up my other applications i may be very upset if it chooses to run in instead of or just as an example on a low end color sun server there are many different possible entry static gray static color and a the sgi iris offer all the above plus bit bit an overlay plane why do only shell widgets have a visual this is strictly by convention it makes it possible for an arbitrary widget to know that the visual it uses can be found by looking for the shell widget that is its ancestor and obtaining the visual of that shell a widget can have its own visual resource if it does it must have its own realize method to use the visual when it calls you should also make this a resource that can be obtained with so other widgets can find it a reasonable value is probably which visual depth and do shells the default value for these resources are set to this is interpreted as the and the default visual of the screen if the widget has no parent it is an and the root of your widget tree if the parent of the widget is not null then the shell copies and depth from its parent and uses as the visual i done all the above and i still get a error why some resource converters cache references this was especially true of and earlier versions of motif why does my widget get destroyed when i call see section of the xt specification it eventually does get destroyed just not immediately the destroy a widget in a process first it and all of its children have a flag set that indicate it is being destroyed it is then put on a list of widgets to be destroyed this way any pending x events or further references to that widget can be cleaned up before the memory is actually freed the second phase is then performed after all event handlers and actions have completed before checking for the next x event at this point the list is and each widget memory is actually free among other things as some further the widgets may be destroyed if the determine that they have no further references to the widgets on the list if so then the phase destruction occurs immediately also if nested event loops are used widgets placed on the destroy list before entering the inner event loop are not destroyed until returning to the outer event loop how do i exit but still execute the the problem is if a simple and entirely reasonable approach to an application is used such as calling exit directly then a widget may not have a chance to clean up any external state such as open sockets temporary files allocated x resources etc this code for simplicity reasons assumes only a single widget widget gw widget gw widget to find widget top for top gw top top top empty return top void gw closure widget gw widget closure data the app specified widget specific data widget gw make it disappear quickly exit one can see that the above code exit immediately after destroying the widget the trouble is the phase destruction may never occur this works for most widgets and most applications but will not work for those widgets that have any external state you might think that since it works now it will always work but remember that part of the reason an object oriented approach is used is so one can be ignorant of the implementation details for each widget which means that the widget may change and someday require that some external state is cleaned up by the destroy one alternative is to modify to set a global flag and then test for that flag in a private event loop however private event loops are upon because it tends to encourage and difficult to maintain practices try the following code instead include extern widget if widget gw endif extern boolean if closure endif extern void if widget gw closure endif widget gw widget gw widget to find widget top for top gw top top top empty return top void gw closure widget gw widget closure data the app specified widget specific data widget gw make it disappear quickly gw null boolean closure closure exit adds a work procedure that will get called when the application is next idle which happens after all the events are processed and the destroy are executed how do i resize a shell widget after it is realized one does resize a shell widget the proper thing is to resize the currently managed child of the shell widget using the geometry change is then to the shell which asks the window manager which may or may not allow the request however the shell must have the resource set to true otherwise it will not even ask the window manager to grant the request and the shell will not resize to change the position of a shell use on the shell not the child and within the limits of the window manager it should be granted why ca handle files it does however unix semantics for when is ready for a file does not fit most peoples intuitive model in unix terms a file descriptor is ready for reading whenever the read call would not block ignoring the setting of optional flags that indicate not to block this works as expected for terminals sockets and pipes for a file the read will always return but the return indicates an no more data the result is the code in the always calls the input handler because it always thinks something is about to be read the is the select system call or on based os it is the poll system call how to get around this on a unix system the best approach is to use another process to check for available input on the file use a pipe to connect the application with this other process and pass the file descriptor from the pipe to a suitable program on bsd systems is tail filename it that select on some systems is not reliable in particular ibm aix this is one where it would work for a while several thousand times and then stop until some other event woke it up this seemed to be the result of a race condition in the kernel ibm claims to have a fix for this pyramid does work at all and possibly others where pipes are implemented as sockets was completely broken but although the writing side wrote in byte blocks the reading side received it all broken up as if it was being put into the pipe a byte at a time you can waste a lot of time by reading small blocks get it by detecting the situation and having select ignore the pipe for by then it had been given the whole block note that all the above descriptions used unix terminology such as read file descriptor pipes etc this is an os dependent area and may not be identical on all systems however the intrinsic designers felt it was a common enough operation that it should be included with part of the toolkit why they did also deal with signals at this point i do know what good books and magazines are there on xt i have a favorite that is the definitive reference to my perspective it offers a reasonable introduction but also goes into the full details of the when i started using it i was already familiar with xt and the concepts behind it so newcomers may or may not find it useful i always found it accurate and complete which means its a pages paul and ralph x window system toolkit the complete programmer guide and specification digital press isbn order number and by isbn also available through dec direct at the other book i commonly to is young doug the x window system applications and programming with xt motif version prentice hall isbn isbn and of course has an entire series of manuals on x and xt ordering is in particular volume is an xt reference done in manual page style the edition is extensively and goes far beyond the mit manual pages i finding it very useful in particular the index and references to other manual pages help a great deal in chasing down related information i read two periodicals the x resource and the the x journal these are the only two dealing specifically with x the x resource is published quarterly by with one of the issues being the mit x consortium technical conference proceedings there is no advertising i found it informative with pretty good depth for orders call or email for editorial matters email adrian table of contents are posted at in in tex form and on in in ascii form the x journal is a trade rag with lots of advertising the articles are informative and oriented toward a less technical audience i read it more to see what going on then with an expectation of learning a great deal but remember i represent a fairly small percentage of people also they have a pretty good collection of people on the advisory board and as columnists call what widgets are available there are three popular widget sets athena the set provided with this is sufficient for most purposes but is on the ugly side recently a look is available for ftp on motif from available for a license fee and commonly shipped on many workstation vendors platforms almost everyone but sun it looks good and works well but personally i think it is poorly implemented the open look toolkit is a set of widgets implementing sun open look specification developed by at t i never used it so ca comment on its quality i heard that it is a pain to actually get in addition the following collection of widgets are also available a library of widgets for sale from graphical software technology it includes bar graph stacked bar graph line graph pie chart xy plot hypertext help spreadsheet and data entry form widgets i never seen them so i ca comment the free widget foundation is attempting to collect a set of freely available widgets included are a editor and a few others the current set of widgets can be obtained via anonymous ftp from the machine in the file the cornell university widgets from gene one of the early widget sets released provides a nice appearance for buttons and has a mini command language probably not so widely used xs the sony widget set this was around during days but seemed to disappear it looked like it had promise the hp widgets the precursor to motif originally written for there exists diffs to get it to work under again a pretty good widget set but has more or less died the precursor to this was the toolkit which was originally implemented for and apparently provided much experience for the designers of xt a widget set i working on it still primitive but you can give it a try in the following specialized widgets are also available implements a layout of widgets supports motif widgets as children part of plots the athena plotting widgets not the athena widgets contact or joe what alternatives to the are there name language vendor c sun oi interviews stanford c however much i like c and admire the skill in both designing and implementing the hopefully some alternative will develop in the next years that uses an object oriented language keep your eyes open and expect some change about the same time a language other than c gaining acceptance how do i pass a float value to first what is going wrong is the structure for an arg is essentially struct string name long value arg and the code arg arg arg name expands to arg arg name you can see that with normal c type conversions the gets the integer instead of the floating point value when the value is copied into the widget resource the bit pattern is different than that required for a floating point value so how to get around this the following macro is from the athena widgets document and i am now it over the previous suggestions define arg n d if sizeof float sizeof arg n d else d arg n how do i write a resource converter courtesy of rich thomson the following discussion of resource converters assumes or resource converters changed between and to allow for and caching of converted values there are several main types of resource converters string to data type data type to string data type to data type i string to data type usually a string to data type converter has a fixed set of strings that will be converted to data type values this is most often used to map names to values name value true false in this case the string to data type converter needs to compare the resource value to the list of fixed strings this is most readily accomplished by the use of the quark mechanism of the resource manager the resource value is turned into a quark which is a unique representation of the string that fits into a single word then the resource quark is compared against the for the fixed strings representing the values if there are many strings in the converter or many converters each with a small number of enumeration strings then a global initialization routine might be used to turn all the resource strings into that way the first time one of these converters is used the strings will be turned into and held in static variables for use in the next of one of the converters ii data type to string this type of converter is slightly easier than the string to data type converters since the use of is necessary instead the data type value is simply converted to a string value probably by the use of data type to string converters are useful for applications that wish to convert an internal data type value into a string so that they can write out a valid resource specification to a file this mechanism can be used to provide a snapshot of application state into a file this snapshot can be used to restore the program to a known state via the usual x resource database mechanisms if you are taking the trouble to write a string to data type converter it is much extra effort to write the data type to string converter writing both at the same time helps to ensure that they are consistent iii data type to data type this type of converter is used to convert an existing data type value to another data type for instance an x pixel value can be converted to an rgb data type that contains separate fields for red green and blue the type signature for a resource converter is as follows typedef boolean display cardinal display args cardinal when the converter is invoked the argument points to the source x resource manager value and the argument points to the destination x resource manager value the argument is an opaque pointer to some data that is specified when the converter is registered the args and arguments allow extra information to be passed to the converter when it is invoked for instance the pixel to rgb structure converter discussed above would need and visual arguments in which to lookup the pixel to obtain the rgb values corresponding to that pixel care must be taken with the argument an has the following type definition and specifies a size and location for a converted value typedef struct unsigned int size addr when the converter is invoked the address may point to a location of the given size for the converted value or the location can be null in the former case the converter should ensure that the size of the destination area is large enough to handle the converted value if the destination area is not large enough then the converter should set the size to the amount of space needed and return false the caller can then ensure that enough space is allocated and the converter if the size is large enough then the converter can simply copy the converted value into the space given and return true if the location is null then the converter can assign the location to the address of a static variable containing the converted value and return true when writing a group of converters this code is often repeated and it becomes convenient to define a macro define done var type if addr if size sizeof type size sizeof type return false else type addr var else addr var size sizeof type return true define str if addr size sizeof string size sizeof string return false else addr str size sizeof string return true inside the converter it is a good idea to perform a little safety checking on the and args arguments to ensure that your converter is being called properly once you have written your converter you need to register it with the the resource converters when creating widgets and their resource values from the resource database to register a converter with a single application context use void context from to converter args cache context string from string to converter args cardinal cache to register a converter with all application contexts use void from to converter args cache string from string to converter args cardinal cache in the there were the routines and these have been by and whenever possible the newer routines should be used when a converter is registered with the a cache argument specifies how converted resource values are to be cached do cache any converted values cache all converted values cache converted values on a per display basis caching converted values that require a to the server is a good idea for instance string to pixel conversions the argument is a routine that is invoked then the resource is destroyed either because its cached reference count has been to zero or because the widget owning the value is being destroyed has the following type definition typedef void cardinal context to args cardinal the is invoked to free any auxiliary storage associated with the to argument but does not actually free the storage pointed to by the to argument itself addr the is passed the extra arguments that were passed to the converter when the conversion was performed for instance and visual arguments for the string to pixel converter since the would need to free the allocated pixel from the as well as the private data passed in when the converter was registered sample converter code can be found in the following files in the mit distribution how do i open multiple displays see application software using xt the x resource issue summer by oliver jones for a complete coverage of the issues involved most of this answer is based on that article in a one uses to add each display to a application context and then to shutdown each display and remove it from the application context the real problems occur when trying to close down a display this can happen ways user selects a quit button on one of the displays user has window manager send a message server disconnect possibly from a message server or network failure i assume you can deal with since it is a problem of translating a widget to a display and removing that display if not then read the oliver jones article the third one is difficult to handle the following is based on the oliver jones article and i include it here because it is a difficult problem the difficulty arises because the design presumed that an error is always and so fatal this is essentially true for a single display x based application but not true for a multiple display program or an application that does things other than display information on an x server when an x error occurs the error handler is called and it returns then an exit happens the only way around this is to use to avoid returning to the error handler the following code fragment demonstrates this include void display main if the is something that given a display pointer can go back to the application specific data and perform any necessary cleanup it should also call for those of you unfamiliar with when is first called it returns a and save enough information in the that a latter execution of can return the program to the same state as if the was just executed the return value of this second is the value of the second argument to there are several about using these but for this purpose it is adequate some other problems you might run into are resource converters that cache resources the most likely symptoms are errors such as or there may be problems with the total number of displays you can open since typically only a limited number of file are available with being a typical value you may also run into authorization problems when trying to connect to a display there was much discussion in about this topic in november of robert posted an article which basically said this is the way it will be and will not change what changed from to to this addresses only changes in the first the general changes for each release are described then a certainly incomplete list of new functions added and others that are now deprecated are listed is a primary goal much of the following information is retrieved from chapter of the mit xt manual and from volume edition from to addition of gadgets widgets new resource type converter interface to handle and additional data variable argument list interface define added with this release changed added and count parameters event handlers had parameter added specification changed changed to an data type from boolean changed to data type from boolean added to extension record obsolete as info is passed to added to extension record obsolete as info is passed to calling must store complete geometry added actually works under from to resource added searching for and other files made more flexible customization resource added resource database support permanently allocated strings allocated strings required for several class fields the args argument to and were changed from to many performance improvements this is summarized from the article xt performance improvements in release by in the x resource issue with to avoid string copies several fields in the class record are indicated as needing permanent strings using an array of strings for resources callback lists to use less memory translation manager and rewritten so it takes less memory translation tables are faster cache of action bindings to are cached better sharing of gc with fields window to widget translation uses less space and faster does not space for widget name since quark is available widget space is allocated to include the constraints over several example programs about a reduction in memory usage functions new with gc with fields get the action table of a class return resource database for a screen register language procedure called to set locale functions new with procedure to call before action lots of initialization work cache reference count for converter specify default resources register a new style converter directly execute a callback list invoke a new style converter release a cached resource value release a list of cached resource values find and call a resource converter invoke converter return the display issue a warning about conversion find a file retrieve for this action return name and class get constraints for a widget return mapping table read the time retrieve the event obtain the selection value obtain the selection value initialize a widget class manually register event handler others register event handler without modify input mask test if subclass of object test if subclass of return list of retrieve most recent event time action for down a widget action for up a widget macro for structure make selection data map a popup indicate action procedure needs a passive grab remove function called after every action find a file return screen of object set the time set for custom cancel a passive button grab cancel a passive key grab release an active keyboard grab release an active pointer grab interfaces to a bunch of functions return window of nearest widget ancestor deprecated replacement when action action action action where are the resources loaded from the resources of a widget are filled in from the following places from highest priority to lowest priority args passed at creation time command line arguments user per host defaults file user defaults file user per application default file system wide per application default file note that are read only once on application startup the result of steps is a single resource database used for further queries the per host defaults file contains for all applications executing on a specific computer this file is either specified with the environment variable or if that is not set then the file host is used the user defaults file is either obtained from the property on the root window of the display or if that is not set then the file is used typically the program is used to set the property please note that this should be kept relatively small as each client that connects to the display must transfer the property a size of around is reasonable some may track changes to the but most do not a user may have many per application default files containing specific to each application the are quite flexible on how this file is found read the next part that describes the various environment variables and how they effect where this file is found the system wide per application default files are typically found in if such a file is not found then the resources are used the are quite flexible on how this file is found read the next part that describes the various environment variables and how they effect where this file is found thanks to oliver jones oj for the following you can use several environment variables to control how resources are loaded for your programs and these environment variables control where xt looks for files as an application is xt loads at most one file from the path defined in and another from the path defined in set if software is installed on your system in such a way that files appear in several different directory suppose for example that you are running sun open windows and you also have some x applications installed in you could set a value like this for and it would cause xt to look up files in both and or wherever your is located n n the value of this environment variable is a list of the contain replacement characters as follows see n the value of the filename parameter or the application class name t the value of the file type in this case the literal string c customization resource only s suffix none for l language locale and l language part of l ja t the territory part of the display language string c the part of the display language string let take apart the example suppose the application class name is also suppose open windows is installed in notice the example lookup n means n means as the application xt tries to open both of the above files in the order shown as soon as it finds one it reads it and uses it and stops looking for others the effect of this path is to search first in then in let consider another example this time let set so it looks for the file in the current working directory then for in the directory n the first path in the list expands to the second expands to this is a convenient setting for debugging because it follows the convention of naming the file in the application source directory so you can run the application from the directory in which you are working and still have the resources loaded properly note when looking for files with for some bizarre reason neither the type nor file suffix is defined so t and s are useless with there another twist you may specify a customization resource value for example you might run the application like this if one of your specifications had the value n c then the expanded would be because the c substitution character takes on the value of the customization resource the default compiled into xt is n c n c n c n n n note some sites replace with a in this batch of default settings the default also compiled into xt is root n c root n c root n c root n root n root n root is either the value of or the user home directory if is not set if you set to some value other than the default xt altogether notice that the quick and dirty way of making your application find your file in your current working directory is to set to a single dot in all this machinery worked differently for many people set their value to a dot followed by a slash what order are executed in courtesy of donna converse converse the library do not guarantee an order this is because both the widget writer and the application writer have the ability to modify the entire contents of the callback list neither one currently knows what the other is doing and so the can not guarantee the order of execution the application programmer can not rely on the widget writer the widget writer is not required to document when the widget will add and remove from the list or what effect this will have therefore the functionality contained in a callback should be independent of the functionality contained in other on the list even though the xt standard in the definition of says specifies the callback list to which the procedure is to be you may not from the word that the callback routines are called in the same order as they have been added to the callback list how do i know if a widget is visible courtesy of donna converse converse i am building a widget needs to know if it is visible i set the visible interest field in core and if my window is completely the core visible flag goes false however if my window is the flag stays set to true right everything is implemented correctly this demonstrates a deficiency in the x protocol and the core widget is reflecting the capabilities of the protocol the deficiency is that the information is available in one way in this case an way the xt specification is accurate in the second and third paragraphs of section so read this section carefully the visible field will not change in response to a event will not be received when the window goes from to that is when the widget or an ancestor is that is when occurs this is the protocol deficiency visibility state and state have specific meanings in the x protocol see the glossary in your and x protocol reference manual is this a problem with or is there something else which needs to be done you see this with any window manager with no window manager if the problem is what is the fastest way to determine if a window is as an application writer keep track with a global boolean in an action routine with translations for and on the shell widget which contains your custom widget as the custom widget writer see the field returned by a call to these are suggestions how do i a widget in xt you ca why use etc unfortunately most code that calls or tends to ignore the possibility of returning null at best it is handled something like ptr type sizeof type if ptr in exit to handle this common case the define the functions and which all use the standard c language functions and but execute if a null value is returned xt error handlers are not supposed to return so this effectively exits in addition if is called with a null pointer it uses to get the initial space this allows code like if ptr ptr type sizeof type else ptr type ptr sizeof type count to be written as ptr ptr sizeof ptr also accepts a null pointer as an argument generally found the xt functions to use however anytime anything potentially large i use the standard functions so i can fully recover from not enough memory errors and are macros for a structure or copying a string struct abc char char struct abc takes care of type casting ptr str a strict interpretation of the reference manual allow an implementation to provide functions that are not with and free code such as char ptr free ptr may not work personally i call any implementation that did this broken and complain to the vendor a common error for motif programmers is to use on a string when they should really be using how to debug an xt application first i getting from pure software this is a great package for tracing memory problems on sun it a bit at but i still it excuse the marketing contact support for more info inserts additional checking instructions directly into the object code produced by existing compilers these instructions check every memory read and write performed by the program under test and detect several types of access errors such as reading memory writing past bounds or writing to freed memory inserts checking logic into all of the code in a program including third party and vendor libraries and system call interfaces in addition tracks memory usage and identifies individual memory leaks using a novel of garbage collection techniques nearly comprehensive memory access checking the target program down typically by a factor of two to five an alternative package that is as for a sun runs on many unix and has pretty similar features is the sentinel debugging environment this replaces and several other c library functions to add additional checks contact for more info next if you are getting any sort of error you need to run in synchronous mode easily accomplished with the command line argument or by setting the variable to with your debugger then set a break point in exit this will let you trace back to the original function being called if you do run in synchronous mode then the actual error may have any number of calls to previously since the calls are and replies from the server are asynchronous next if you are having trouble with window layout you can use the resource or the class resource to cause the widget name to be identified with each window for example example true example click in new window will give the normal information but the widget name and class of each window is included this can help for checking the location and size of widgets next if you are having trouble with geometry managers or you want to test the way a widget manages it children you can try this acts as a filter between any children and a geometry manager and checks the behaviour of both it a very clever idea the most unfortunate problem is debugging a callback while the application is executing a grab of the keyboard or mouse such as from a menu the server effectively locks up and you need to go to another machine and kill the debugger manually the server locks up because the application being has said no one else can have access to the keyboard but the application is not stopped waiting because the debugger is waiting for your commands unfortunately you ca give them because all the input is going to your application which is stopped the best way to debug this kind of problem is with two machines on your desk running the program under a debugger or other environment on one machine and running the application on the other possibly using a command sequence like this display gdb application your favorite debugger or this gdb application gdb set environment display gdb run i believe a c debugger has a method of dealing with this by calling the functions to release any grabs during debugging widget problems requires pretty good debugging skills and knowledge of how widgets work you can go a long way without knowing the of a particular widget but not very far without understanding how a widget works use of conditional and adding print statements with the debugger help a great deal why do and work i have got a delicate problem with the three routines and the problem i have is that when i use them in my application they seem not to be properly i have made a handy little where everything works perfect but in my real application nothing happens the introduction in of the functions those routines see for other changes in and what happens is they use a default application context different then the one you may have created since events and are distributed on a per application context basis and you are using two application contexts you wo get those events for example app class desc desc argv args app would never invoke the timeout what is and how can i implement drag and drop courtesy of roger reynolds feb is a for moving data between clients in an intuitive fashion motif version supports capabilities has supported all along the two protocols are not with each other and so far as i know they are not published i wrote a package called which is designed to be a flexible public protocol for doing drag drop operations between clients my intention was to provide a tool which would make it easy for people to support a standard protocol in the programs they develop and contribute or sell regardless of what widget set is used as long as it is based on xt the implementation is based upon my understanding of the conventions for more details read the code i have heard from dozens of people using who like it and feel that it works a whole lot better than motif stuff also there seem to be many who think that it is neat but are constrained to use motif anyway the latest and some other stuff is available for ftp from in a possibly older version is also available on in pete ware ware cis dept ohio state university hall neil columbus oh 